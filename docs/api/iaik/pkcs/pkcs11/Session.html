<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Wed Jan 24 10:53:07 CET 2018 -->
<TITLE>
IAIK PKCS#11 Wrapper API Documentation: Class  Session
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Session.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

        
          <b>IAIK PKCS#11 Wrapper</b><br>
          <font size="-1">version 1.5</font>
         
      </EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/Module.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/SessionInfo.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Session.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;<A HREF="#inner_class_summary">INNER</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
iaik.pkcs.pkcs11</FONT>
<BR>
Class  Session</H2>
<PRE>
java.lang.Object
  |
  +--<B>iaik.pkcs.pkcs11.Session</B>
</PRE>
<HR>
<DL>
<DT>public class <B>Session</B><DT>extends java.lang.Object</DL>

<P>
Session objects are used to perform cryptographic operations on a token. The application gets a
 Session object by calling openSession on a certain Token object. Having the session object, the
 application may log-in the user, if required.
 
 <pre>
 <code>
   TokenInfo tokenInfo = token.getTokenInfo();
   // check, if log-in of the user is required at all
   if (tokenInfo.isLoginRequired()) {
     // check, if the token has own means to authenticate the user; e.g. a PIN-pad on the reader
     if (tokenInfo.isProtectedAuthenticationPath()) {
       System.out.println("Please enter the user PIN at the PIN-pad of your reader.");
       session.login(Session.UserType.USER, null); // the token prompts the PIN by other means; e.g. PIN-pad
     } else {
       System.out.print("Enter user-PIN and press [return key]: ");
       System.out.flush();
       BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
       String userPINString = input.readLine();
       session.login(Session.UserType.USER, userPINString.toCharArray());
     }
   }
 </code>
 </pre>
 
 With this session object the application can search for token objects and perform a cryptographic
 operation. For example, to find private RSA keys that the application can use for signing, you
 can write:
 
 <pre>
 <code>
   RSAPrivateKey privateSignatureKeyTemplate = new RSAPrivateKey();
   privateSignatureKeyTemplate.getSign().setBooleanValue(Boolean.TRUE);
 
   session.findObjectsInit(privateSignatureKeyTemplate);
   Object[] privateSignatureKeys;
 
   List signatureKeyList = new Vector(4);
   while ((privateSignatureKeys = session.findObjects(1)).length > 0) {
     signatureKeyList.add(privateSignatureKeys[0]);
   }
   session.findObjectsFinal();
 </code>
 </pre>
 
 Having chosen one of this keys, the application can create a signature value using it.
 
 <pre>
 <code>
   // e.g. the encoded digest info object that contains an identifier of the
   // hash algorithm and the hash value
   byte[] toBeSigned;
 
   // toBeSigned = ... assign value
 
   RSAPrivateKey selectedSignatureKey;
 
   // selectedSignatureKey = ... assign one of the available signature keys
 
   // initialize for signing
   session.signInit(Mechanism.RSA_PKCS, selectedSignatureKey);
 
   // sign the data to be signed
   byte[] signatureValue = session.sign(toBeSigned);
 </code>
 </pre>
 
 If the application does not need the session any longer, it should close the session.
 
 <pre>
 <code>
   session.closeSession();
 </code>
 </pre>
<P>
<DL>
<DT><B>Version: </B><DD>1.0</DD>
<DT><B>Author: </B><DD>Karl Scheibelhofer</DD>
<DT><B>See Also: </B><DD><A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html"><CODE>Object</CODE></A>, 
<A HREF="../../../iaik/pkcs/pkcs11/parameters/Parameters.html"><CODE>Parameters</CODE></A>, 
<A HREF="../../../iaik/pkcs/pkcs11/Session.html"><CODE>Session</CODE></A>, 
<A HREF="../../../iaik/pkcs/pkcs11/SessionInfo.html"><CODE>SessionInfo</CODE></A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->

<A NAME="inner_class_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Inner Class Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.UserType.html">Session.UserType</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This interface defines the different user types of PKCS#11.</TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../iaik/pkcs/pkcs11/Module.html">Module</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#module_">module_</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A reference to the underlying PKCS#11 module to perform the operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../iaik/pkcs/pkcs11/wrapper/PKCS11.html">PKCS11</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#pkcs11Module_">pkcs11Module_</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A reference to the underlying PKCS#11 module to perform the operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#sessionHandle_">sessionHandle_</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The session handle to perform the operations with.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../iaik/pkcs/pkcs11/Token.html">Token</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#token_">token_</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The token to perform the operations on.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#Session(iaik.pkcs.pkcs11.Token, long)">Session</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Token.html">Token</A>&nbsp;token,
        long&nbsp;sessionHandle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructor taking the token and the session handle.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#cancelFunction()">cancelFunction</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Legacy function that will normally throw an PKCS11Exception with the error-code
 PKCS11Constants.CKR_FUNCTION_NOT_PARALLEL.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#closeSession()">closeSession</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closes this session.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#copyObject(iaik.pkcs.pkcs11.objects.Object, iaik.pkcs.pkcs11.objects.Object)">copyObject</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;sourceObject,
           <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy an existing object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#createObject(iaik.pkcs.pkcs11.objects.Object)">createObject</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new object on the token (or in the session).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#decrypt(byte[])">decrypt</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrypts the given data with the key and mechansim given to the decryptInit method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#decryptDigestUpdate(byte[])">decryptDigestUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dual-function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#decryptFinal()">decryptFinal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method finalizes a decrpytion operation and returns the final result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#decryptInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)">decryptInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
            <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new decryption operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#decryptUpdate(byte[])">decryptUpdate</A></B>(byte[]&nbsp;encryptedPart)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be used to decrypt multiple pieces of data; e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#decryptVerifyUpdate(byte[])">decryptVerifyUpdate</A></B>(byte[]&nbsp;encryptedPart)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dual-function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#deriveKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)">deriveKey</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
          <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;baseKey,
          <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;template)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derives a new key from a specified base key unsing the given mechanism.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#destroyObject(iaik.pkcs.pkcs11.objects.Object)">destroyObject</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroy a certain object on the token (or in the session).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#digest(byte[])">digest</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Digests the given data with the mechansim given to the digestInit method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#digestEncryptedUpdate(byte[])">digestEncryptedUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dual-function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#digestFinal()">digestFinal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method finalizes a digesting operation and returns the final result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#digestInit(iaik.pkcs.pkcs11.Mechanism)">digestInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new digesting operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#digestKey(iaik.pkcs.pkcs11.objects.SecretKey)">digestKey</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/SecretKey.html">SecretKey</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is similar to digestUpdate and can be combined with it during one digesting
 operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#digestUpdate(byte[])">digestUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be used to digest multiple pieces of data; e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#encrypt(byte[])">encrypt</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encrypts the given data with the key and mechansim given to the encryptInit method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#encryptFinal()">encryptFinal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method finalizes an encrpytion operation and returns the final result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#encryptInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)">encryptInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
            <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new encryption operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#encryptUpdate(byte[])">encryptUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be used to encrypt multiple pieces of data; e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#equals(java.lang.Object)">equals</A></B>(java.lang.Object&nbsp;otherObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compares the sessionHandle and token_ of this object with the other object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#findObjects(int)">findObjects</A></B>(int&nbsp;maxObjectCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds objects that match the template object passed to findObjectsInit.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#findObjectsFinal()">findObjectsFinal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finalizes a find operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#findObjectsInit(iaik.pkcs.pkcs11.objects.Object)">findObjectsInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a find operations that provides means to find objects by passing a template object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#generateKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Object)">generateKey</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
            <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;template)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a new secret key or a set of domain parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/KeyPair.html">KeyPair</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#generateKeyPair(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Object, iaik.pkcs.pkcs11.objects.Object)">generateKeyPair</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;publicKeyTemplate,
                <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;privateKeyTemplate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a new public key - private key key-pair and use the set attributes of the template
 objects for setting the attributes of the new public key and private key objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#generateRandom(int)">generateRandom</A></B>(int&nbsp;numberOfBytesToGenerate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generates a certain number of random bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getAttributeValues(iaik.pkcs.pkcs11.objects.Object)">getAttributeValues</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;objectToRead)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads all the attributes of the given Object from the token and returns a new Object that
 contains all these attributes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getFunctionStatus()">getFunctionStatus</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Legacy function that will normally throw an PKCS11Exception with the error-code
 PKCS11Constants.CKR_FUNCTION_NOT_PARALLEL.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/Module.html">Module</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getModule()">getModule</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the Module which this Session object operates with.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getObjectSize(iaik.pkcs.pkcs11.objects.Object)">getObjectSize</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the size of the specified object in bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getOperationState()">getOperationState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the current operation state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getSessionHandle()">getSessionHandle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the handle of this session.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/SessionInfo.html">SessionInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getSessionInfo()">getSessionInfo</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get information about this session.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/Token.html">Token</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getToken()">getToken</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the token that created this Session object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#hashCode()">hashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The overriding of this method should ensure that the objects of this class work correctly in a
 hashtable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#initPIN(char[])">initPIN</A></B>(char[]&nbsp;pin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes the user-PIN.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#isSetUtf8Encoding()">isSetUtf8Encoding</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether UTF8 encoding is set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#login(boolean, char[])">login</A></B>(boolean&nbsp;userType,
      char[]&nbsp;pin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logs in the user or the security officer to the session.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#logout()">logout</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logs out this session.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#seedRandom(byte[])">seedRandom</A></B>(byte[]&nbsp;seed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mixes additional seeding material into the random number generator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#setAttributeValues(iaik.pkcs.pkcs11.objects.Object, iaik.pkcs.pkcs11.objects.Object)">setAttributeValues</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;objectToUpdate,
                   <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets all present attributes of the given template object an writes them to the object to update
 on the token (or in the session).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#setOperationState(byte[], iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)">setOperationState</A></B>(byte[]&nbsp;operationState,
                  <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;encryptionKey,
                  <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;authenticationKey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the operation state of this session to a previously saved one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#setPIN(char[], char[])">setPIN</A></B>(char[]&nbsp;oldPin,
       char[]&nbsp;newPin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the user-PIN to a new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#sign(byte[])">sign</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signs the given data with the key and mechansim given to the signInit method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#signEncryptUpdate(byte[])">signEncryptUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dual-function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#signFinal()">signFinal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method finalizes a signing operation and returns the final result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#signInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)">signInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
         <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new signing operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#signRecover(byte[])">signRecover</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signs the given data with the key and mechansim given to the signRecoverInit method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#signRecoverInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)">signRecoverInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new signing operation for signing with recovery.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#signUpdate(byte[])">signUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be used to sign multiple pieces of data; e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the string representation of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#unwrapKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key, byte[], iaik.pkcs.pkcs11.objects.Object)">unwrapKey</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
          <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;unwrappingKey,
          byte[]&nbsp;wrappedKey,
          <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;keyTemplate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unwraps (decrypts) the given encrypted key with the unwrapping key using the given mechanism.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#verify(byte[], byte[])">verify</A></B>(byte[]&nbsp;data,
       byte[]&nbsp;signature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verifies the given signature against the given data with the key and mechansim given to the
 verifyInit method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#verifyFinal(byte[])">verifyFinal</A></B>(byte[]&nbsp;signature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method finalizes a verification operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#verifyInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)">verifyInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
           <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new verification operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#verifyRecover(byte[])">verifyRecover</A></B>(byte[]&nbsp;signature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signs the given data with the key and mechansim given to the signRecoverInit method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#verifyRecoverInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)">verifyRecoverInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                  <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new verification operation for verification with data recovery.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#verifyUpdate(byte[])">verifyUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be used to verify a signature with multiple pieces of data; e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#wrapKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)">wrapKey</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
        <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;wrappingKey,
        <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wraps (encrypts) the given key with the wrapping key using the given mechanism.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, finalize, getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="module_"><!-- --></A><H3>
module_</H3>
<PRE>
protected <A HREF="../../../iaik/pkcs/pkcs11/Module.html">Module</A> <B>module_</B></PRE>
<DL>
<DD>A reference to the underlying PKCS#11 module to perform the operations.</DL>
<HR>

<A NAME="pkcs11Module_"><!-- --></A><H3>
pkcs11Module_</H3>
<PRE>
protected <A HREF="../../../iaik/pkcs/pkcs11/wrapper/PKCS11.html">PKCS11</A> <B>pkcs11Module_</B></PRE>
<DL>
<DD>A reference to the underlying PKCS#11 module to perform the operations.</DL>
<HR>

<A NAME="sessionHandle_"><!-- --></A><H3>
sessionHandle_</H3>
<PRE>
protected long <B>sessionHandle_</B></PRE>
<DL>
<DD>The session handle to perform the operations with.</DL>
<HR>

<A NAME="token_"><!-- --></A><H3>
token_</H3>
<PRE>
protected <A HREF="../../../iaik/pkcs/pkcs11/Token.html">Token</A> <B>token_</B></PRE>
<DL>
<DD>The token to perform the operations on.</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Session(iaik.pkcs.pkcs11.Token, long)"><!-- --></A><H3>
Session</H3>
<PRE>
protected <B>Session</B>(<A HREF="../../../iaik/pkcs/pkcs11/Token.html">Token</A>&nbsp;token,
                  long&nbsp;sessionHandle)</PRE>
<DL>
<DD>Constructor taking the token and the session handle.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>token</CODE> - The token this session operates with.<DD><CODE>sessionHandle</CODE> - The session handle to perform the operations with.</DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="initPIN(char[])"><!-- --></A><H3>
initPIN</H3>
<PRE>
public void <B>initPIN</B>(char[]&nbsp;pin)
             throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes the user-PIN. Can only be called from a read-write security officer session. May be
 used to set a new user-PIN if the user-PIN is locked.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pin</CODE> - The new user-PIN. This parameter may be null, if the token has a protected
          authentication path. Refer to the PKCS#11 standard for details.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If the session has not the right to set the PIN of if the operation fails for some
              other reason.</DL>
</DD>
</DL>
<HR>

<A NAME="setPIN(char[], char[])"><!-- --></A><H3>
setPIN</H3>
<PRE>
public void <B>setPIN</B>(char[]&nbsp;oldPin,
                   char[]&nbsp;newPin)
            throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Set the user-PIN to a new value. Can only be called from a read-write sessions.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>oldPin</CODE> - The old (current) user-PIN.<DD><CODE>newPin</CODE> - The new value for the user-PIN.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If setting the new PIN fails.</DL>
</DD>
</DL>
<HR>

<A NAME="closeSession()"><!-- --></A><H3>
closeSession</H3>
<PRE>
public void <B>closeSession</B>()
                  throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Closes this session.<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If closing the session failed.</DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(java.lang.Object&nbsp;otherObject)</PRE>
<DL>
<DD>Compares the sessionHandle and token_ of this object with the other object. Returns only true,
 if those are equal in both objects.<DD><DL>
<DT><B>Overrides:</B><DD><CODE>equals</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>otherObject</CODE> - The other Session object.<DT><B>Returns:</B><DD>True, if other is an instance of Token and the session handles and tokens of both
         objects are equal. False, otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>The overriding of this method should ensure that the objects of this class work correctly in a
 hashtable.<DD><DL>
<DT><B>Overrides:</B><DD><CODE>hashCode</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>The hash code of this object. Gained from the sessionHandle.</DL>
</DD>
</DL>
<HR>

<A NAME="getSessionHandle()"><!-- --></A><H3>
getSessionHandle</H3>
<PRE>
public long <B>getSessionHandle</B>()</PRE>
<DL>
<DD>Get the handle of this session.<DD><DL>
<DT><B>Returns:</B><DD>The handle of this session.</DL>
</DD>
</DL>
<HR>

<A NAME="getSessionInfo()"><!-- --></A><H3>
getSessionInfo</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/SessionInfo.html">SessionInfo</A> <B>getSessionInfo</B>()
                           throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Get information about this session.<DD><DL>
<DT><B>Returns:</B><DD>An object providing information about this session.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If getting the information failed.</DL>
</DD>
</DL>
<HR>

<A NAME="getModule()"><!-- --></A><H3>
getModule</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/Module.html">Module</A> <B>getModule</B>()</PRE>
<DL>
<DD>Get the Module which this Session object operates with.<DD><DL>
<DT><B>Returns:</B><DD>The module of this session.</DL>
</DD>
</DL>
<HR>

<A NAME="getToken()"><!-- --></A><H3>
getToken</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/Token.html">Token</A> <B>getToken</B>()</PRE>
<DL>
<DD>Get the token that created this Session object.<DD><DL>
<DT><B>Returns:</B><DD>The token of this session.</DL>
</DD>
</DL>
<HR>

<A NAME="getOperationState()"><!-- --></A><H3>
getOperationState</H3>
<PRE>
public byte[] <B>getOperationState</B>()
                         throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Get the current operation state. This state can be used later to restore the operation to
 exactly this state.<DD><DL>
<DT><B>Returns:</B><DD>The current operation state as a byte array.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If saving the state fails or is not possible.<DT><B>See Also: </B><DD><A HREF="../../../iaik/pkcs/pkcs11/Session.html#setOperationState(byte[], iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)"><CODE>setOperationState(byte[],Key,Key)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setOperationState(byte[], iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
setOperationState</H3>
<PRE>
public void <B>setOperationState</B>(byte[]&nbsp;operationState,
                              <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;encryptionKey,
                              <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;authenticationKey)
                       throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Sets the operation state of this session to a previously saved one. This method may need the
 key used during the saved operation to continue, because it may not be possible to save a key
 into the state's byte array. Refer to the PKCS#11 standard for details on this function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>operationState</CODE> - The previously saved state as returned by getOperationState().<DD><CODE>encryptionKey</CODE> - A encryption or decryption key, if a encryption or decryption operation was saved
          which should be continued, but the keys could not be saved.<DD><CODE>authenticationKey</CODE> - A signing, verification of MAC key, if a signing, verification or MAC operation needs
          to be restored that could not save the key.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If restoring the state fails.<DT><B>See Also: </B><DD><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getOperationState()"><CODE>getOperationState()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isSetUtf8Encoding()"><!-- --></A><H3>
isSetUtf8Encoding</H3>
<PRE>
public boolean <B>isSetUtf8Encoding</B>()</PRE>
<DL>
<DD>Returns whether UTF8 encoding is set.<DD><DL>
<DT><B>Returns:</B><DD>true, if UTF8 is used as character encoding for character array attributes and PINs.</DL>
</DD>
</DL>
<HR>

<A NAME="login(boolean, char[])"><!-- --></A><H3>
login</H3>
<PRE>
public void <B>login</B>(boolean&nbsp;userType,
                  char[]&nbsp;pin)
           throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Logs in the user or the security officer to the session. Notice that all sessions of a token
 have the same login state; i.e. if you login the user to one session all other open sessions of
 this token get user rights.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>userType</CODE> - UserType.SO for the security officer or UserType.USER to login the user.<DD><CODE>pin</CODE> - The PIN. The security officer-PIN or the user-PIN depending on the userType parameter.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If login fails.</DL>
</DD>
</DL>
<HR>

<A NAME="logout()"><!-- --></A><H3>
logout</H3>
<PRE>
public void <B>logout</B>()
            throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Logs out this session.<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If logging out the session fails.</DL>
</DD>
</DL>
<HR>

<A NAME="createObject(iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
createObject</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A> <B>createObject</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)
                    throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Create a new object on the token (or in the session). The application must provide a template
 that holds enough information to create a certain object. For instance, if the application
 wants to create a new DES key object it creates a new instance of the DESSecretKey class to
 serve as a template. The application must set all attributes of this new object which are
 required for the creation of such an object on the token. Then it passes this DESSecretKey
 object to this method to create the object on the token. Example: <code>
   DESSecretKey desKeyTemplate = new DESSecretKey();
   // the key type is set by the DESSecretKey's constructor, so you need not do it
   desKeyTemplate.setValue(myDesKeyValueAs8BytesLongByteArray);
   desKeyTemplate.setToken(Boolean.TRUE);
   desKeyTemplate.setPrivate(Boolean.TRUE);
   desKeyTemplate.setEncrypt(Boolean.TRUE);
   desKeyTemplate.setDecrypt(Boolean.TRUE);
   ...
   DESSecretKey theCreatedDESKeyObject = (DESSecretKey) userSession.createObject(desKeyTemplate);
 </code> Refer to the PKCS#11 standard to find out what attributes must be set for certain types
 of objects to create them on the token.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>templateObject</CODE> - The template object that holds all values that the new object on the token should
          contain. (this is not a java.lang.Object!)<DT><B>Returns:</B><DD>A new PKCS#11 Object (this is not a java.lang.Object!) that serves holds all the
         (readable) attributes of the object on the token. In contrast to the templateObject,
         this object might have certain attributes set to token-dependent default-values.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If the creation of the new object fails. If it fails, the no new object was
              created on the token.</DL>
</DD>
</DL>
<HR>

<A NAME="copyObject(iaik.pkcs.pkcs11.objects.Object, iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
copyObject</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A> <B>copyObject</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;sourceObject,
                         <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)
                  throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Copy an existing object. The source object and a template object are given. Any value set in
 the template object will override the corresponding value from the source object, when the new
 object ist created. See the PKCS#11 standard for details.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sourceObject</CODE> - The source object of the copy operation.<DD><CODE>templateObject</CODE> - A template object which's attribute values are used for the new object; i.e. they have
          higher priority than the attribute values from the source object. May be null; in that
          case the new object is just a one-to-one copy of the sourceObject.<DT><B>Returns:</B><DD>The new object that is created by copying the source object and setting attributes to
         the values given by the templateObject.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If copying the object fails for some reason.</DL>
</DD>
</DL>
<HR>

<A NAME="setAttributeValues(iaik.pkcs.pkcs11.objects.Object, iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
setAttributeValues</H3>
<PRE>
public void <B>setAttributeValues</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;objectToUpdate,
                               <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)
                        throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Gets all present attributes of the given template object an writes them to the object to update
 on the token (or in the session). Both parameters may refer to the same Java object. This is
 possible, because this method only needs the object handle of the objectToUpdate, and gets the
 attributes to set from the template. This means, an application can get the object using
 createObject of findObject, then modify attributes of this Java object and then call this
 method passing this object as both parameters. This will update the object on the token to the
 values as modified in the Java object.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>objectToUpdate</CODE> - The attributes of this object get updated.<DD><CODE>templateObject</CODE> - This methods gets all present attributes of this template object and set this
          attributes at the objectToUpdate.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If updateing the attributes fails. All or no attributes are updated.</DL>
</DD>
</DL>
<HR>

<A NAME="getAttributeValues(iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
getAttributeValues</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A> <B>getAttributeValues</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;objectToRead)
                          throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Reads all the attributes of the given Object from the token and returns a new Object that
 contains all these attributes. The given objectToRead and the returned Object are different
 Java objects. This method just uses the object handle of the given object, it does not modify
 anything in this object.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>objectToRead</CODE> - The object to newly read from the token.<DT><B>Returns:</B><DD>A new Object holding all attributes that this method just read from the token.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If reading the attributes fails.</DL>
</DD>
</DL>
<HR>

<A NAME="destroyObject(iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
destroyObject</H3>
<PRE>
public void <B>destroyObject</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;object)
                   throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Destroy a certain object on the token (or in the session). Give the object that you want to
 destroy. This method uses only the internal object handle of the given object to identify the
 object.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - The object that should be destroyed.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If the object could not be destroyed.</DL>
</DD>
</DL>
<HR>

<A NAME="getObjectSize(iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
getObjectSize</H3>
<PRE>
public long <B>getObjectSize</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;object)
                   throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Get the size of the specified object in bytes. This size specifies how much memory the object
 takes up on the token.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - The object to get the size for.<DT><B>Returns:</B><DD>The object's size bytes.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If determining the size fails.</DL>
</DD>
</DL>
<HR>

<A NAME="findObjectsInit(iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
findObjectsInit</H3>
<PRE>
public void <B>findObjectsInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)
                     throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a find operations that provides means to find objects by passing a template object.
 This method get all set attributes of the template object ans searches for all objects on the
 token that match with these attributes.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>templateObject</CODE> - The object that serves as a template for searching. If this object is null, the find
          operation will find all objects that this session can see. Notice, that only a user
          session will see private objects.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing the find operation fails.</DL>
</DD>
</DL>
<HR>

<A NAME="findObjects(int)"><!-- --></A><H3>
findObjects</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>[] <B>findObjects</B>(int&nbsp;maxObjectCount)
                     throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Finds objects that match the template object passed to findObjectsInit. The application must
 call findObjectsInit before calling this method. With maxObjectCount the application can
 specifay how many objects to return at once; i.e. the application can get all found objects by
 susequent calls to this method like maxObjectCount(1) until it receives an empty array (this
 method never returns null!).<DD><DL>
<DT><B>Parameters:</B><DD><CODE>maxObjectCount</CODE> - Specifies how many objects to return with this call.<DT><B>Returns:</B><DD>An array of found objects. The maximum size of this array is maxObjectCount, the
         minimum length is 0. Never returns null.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - A plain TokenException if something during PKCS11 FindObject went wrong, a
              TokenException with a nested TokenException if the Exception is raised during
              object parsing.</DL>
</DD>
</DL>
<HR>

<A NAME="findObjectsFinal()"><!-- --></A><H3>
findObjectsFinal</H3>
<PRE>
public void <B>findObjectsFinal</B>()
                      throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Finalizes a find operation. The application must call this method to finalize a find operation
 before attempting to start any other operation.<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If finalizing the current find operation was not possible.</DL>
</DD>
</DL>
<HR>

<A NAME="encryptInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
encryptInit</H3>
<PRE>
public void <B>encryptInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                        <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
                 throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new encryption operation. The application must call this method before calling
 any other encrypt* operation. Before initializing a new operation, any currently pending
 operation must be finalized using the appropriate *Final method (e.g. digestFinal()). There are
 exceptions for dual-function operations. This method requires the mechansim to use for
 encrpytion and the key for this oepration. The key must have set its encryption flag. For the
 mechanism the application may use a constant defined in the Mechanism class. Notice that the
 key and the mechanism must be compatible; i.e. you cannot use a DES key with the RSA mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.DES_CBC.<DD><CODE>key</CODE> - The decryption key to use.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="encrypt(byte[])"><!-- --></A><H3>
encrypt</H3>
<PRE>
public byte[] <B>encrypt</B>(byte[]&nbsp;data)
               throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Encrypts the given data with the key and mechansim given to the encryptInit method. This method
 finalizes the current encryption operation; i.e. the application need (and should) not call
 encryptFinal() after this call. For encrypting multiple pices of data use encryptUpdate and
 encryptFinal.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The data to encrpyt.<DT><B>Returns:</B><DD>The encrpyted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If encrypting failed.</DL>
</DD>
</DL>
<HR>

<A NAME="encryptUpdate(byte[])"><!-- --></A><H3>
encryptUpdate</H3>
<PRE>
public byte[] <B>encryptUpdate</B>(byte[]&nbsp;part)
                     throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method can be used to encrypt multiple pieces of data; e.g. buffer-size pieces when
 reading the data from a stream. Encrypts the given data with the key and mechansim given to the
 encryptInit method. The application must call encryptFinal to get the final result of the
 encryption after feeding in all data using this method.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to encrpt.<DT><B>Returns:</B><DD>The intermediate encryption result. May not be available. To get the final result call
         encryptFinal.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If encrypting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="encryptFinal()"><!-- --></A><H3>
encryptFinal</H3>
<PRE>
public byte[] <B>encryptFinal</B>()
                    throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method finalizes an encrpytion operation and returns the final result. Use this method, if
 you fed in the data using encryptUpdate. If you used the encrypt(byte[]) method, you need not
 (and shall not) call this method, because encrypt(byte[]) finalizes the encryption itself.<DD><DL>
<DT><B>Returns:</B><DD>The final result of the encryption; i.e. the encrypted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If calculating the final result failed.</DL>
</DD>
</DL>
<HR>

<A NAME="decryptInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
decryptInit</H3>
<PRE>
public void <B>decryptInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                        <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
                 throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new decryption operation. The application must call this method before calling
 any other decrypt* operation. Before initializing a new operation, any currently pending
 operation must be finalized using the appropriate *Final method (e.g. digestFinal()). There are
 exceptions for dual-function operations. This method requires the mechansim to use for
 decrpytion and the key for this oepration. The key must have set its decryption flag. For the
 mechanism the application may use a constant defined in the Mechanism class. Notice that the
 key and the mechanism must be compatible; i.e. you cannot use a DES key with the RSA mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.DES_CBC.<DD><CODE>key</CODE> - The decryption key to use.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="decrypt(byte[])"><!-- --></A><H3>
decrypt</H3>
<PRE>
public byte[] <B>decrypt</B>(byte[]&nbsp;data)
               throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Decrypts the given data with the key and mechansim given to the decryptInit method. This method
 finalizes the current decryption operation; i.e. the application need (and should) not call
 decryptFinal() after this call. For decrypting multiple pices of data use decryptUpdate and
 decryptFinal.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The data to decrpyt.<DT><B>Returns:</B><DD>The decrpyted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If decrypting failed.</DL>
</DD>
</DL>
<HR>

<A NAME="decryptUpdate(byte[])"><!-- --></A><H3>
decryptUpdate</H3>
<PRE>
public byte[] <B>decryptUpdate</B>(byte[]&nbsp;encryptedPart)
                     throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method can be used to decrypt multiple pieces of data; e.g. buffer-size pieces when
 reading the data from a stream. Decrypts the given data with the key and mechansim given to the
 decryptInit method. The application must call decryptFinal to get the final result of the
 encryption after feeding in all data using this method.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>encryptedPart</CODE> - The piece of data to decrpt.<DT><B>Returns:</B><DD>The intermediate decryption result. May not be available. To get the final result call
         decryptFinal.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If decrypting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="decryptFinal()"><!-- --></A><H3>
decryptFinal</H3>
<PRE>
public byte[] <B>decryptFinal</B>()
                    throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method finalizes a decrpytion operation and returns the final result. Use this method, if
 you fed in the data using decryptUpdate. If you used the decrypt(byte[]) method, you need not
 (and shall not) call this method, because decrypt(byte[]) finalizes the decryption itself.<DD><DL>
<DT><B>Returns:</B><DD>The final result of the decryption; i.e. the decrypted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If calculating the final result failed.</DL>
</DD>
</DL>
<HR>

<A NAME="digestInit(iaik.pkcs.pkcs11.Mechanism)"><!-- --></A><H3>
digestInit</H3>
<PRE>
public void <B>digestInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism)
                throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new digesting operation. The application must call this method before calling any
 other digest* operation. Before initializing a new operation, any currently pending operation
 must be finalized using the appropriate *Final method (e.g. digestFinal()). There are
 exceptions for dual-function operations. This method requires the mechansim to use for
 digesting for this oepration. For the mechanism the application may use a constant defined in
 the Mechanism class.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.SHA_1.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="digest(byte[])"><!-- --></A><H3>
digest</H3>
<PRE>
public byte[] <B>digest</B>(byte[]&nbsp;data)
              throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Digests the given data with the mechansim given to the digestInit method. This method finalizes
 the current digesting operation; i.e. the application need (and should) not call digestFinal()
 after this call. For digesting multiple pices of data use digestUpdate and digestFinal.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The data to digest.<DT><B>Returns:</B><DD>The digested data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If digesting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="digestUpdate(byte[])"><!-- --></A><H3>
digestUpdate</H3>
<PRE>
public void <B>digestUpdate</B>(byte[]&nbsp;part)
                  throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method can be used to digest multiple pieces of data; e.g. buffer-size pieces when reading
 the data from a stream. Digests the given data with the mechansim given to the digestInit
 method. The application must call digestFinal to get the final result of the digesting after
 feeding in all data using this method.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to digest.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If digesting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="digestKey(iaik.pkcs.pkcs11.objects.SecretKey)"><!-- --></A><H3>
digestKey</H3>
<PRE>
public void <B>digestKey</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/SecretKey.html">SecretKey</A>&nbsp;key)
               throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method is similar to digestUpdate and can be combined with it during one digesting
 operation. This method digests the value of the given secret key.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - The key to digest the value of.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If digesting the key failed.</DL>
</DD>
</DL>
<HR>

<A NAME="digestFinal()"><!-- --></A><H3>
digestFinal</H3>
<PRE>
public byte[] <B>digestFinal</B>()
                   throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method finalizes a digesting operation and returns the final result. Use this method, if
 you fed in the data using digestUpdate and/or digestKey. If you used the digest(byte[]) method,
 you need not (and shall not) call this method, because digest(byte[]) finalizes the digesting
 itself.<DD><DL>
<DT><B>Returns:</B><DD>The final result of the digesting; i.e. the message digest.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If calculating the final message digest failed.</DL>
</DD>
</DL>
<HR>

<A NAME="signInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
signInit</H3>
<PRE>
public void <B>signInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                     <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
              throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new signing operation. Use it for signatures and MACs. The application must call
 this method before calling any other sign* operation. Before initializing a new operation, any
 currently pending operation must be finalized using the appropriate *Final method (e.g.
 digestFinal()). There are exceptions for dual-function operations. This method requires the
 mechansim to use for signing and the key for this oepration. The key must have set its sign
 flag. For the mechanism the application may use a constant defined in the Mechanism class.
 Notice that the key and the mechanism must be compatible; i.e. you cannot use a DES key with
 the RSA mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.RSA_PKCS.<DD><CODE>key</CODE> - The signing key to use.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="sign(byte[])"><!-- --></A><H3>
sign</H3>
<PRE>
public byte[] <B>sign</B>(byte[]&nbsp;data)
            throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Signs the given data with the key and mechansim given to the signInit method. This method
 finalizes the current signing operation; i.e. the application need (and should) not call
 signFinal() after this call. For signing multiple pices of data use signUpdate and signFinal.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The data to sign.<DT><B>Returns:</B><DD>The signed data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If signing the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="signUpdate(byte[])"><!-- --></A><H3>
signUpdate</H3>
<PRE>
public void <B>signUpdate</B>(byte[]&nbsp;part)
                throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method can be used to sign multiple pieces of data; e.g. buffer-size pieces when reading
 the data from a stream. Signs the given data with the mechansim given to the signInit method.
 The application must call signFinal to get the final result of the signing after feeding in all
 data using this method.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to sign.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If signing the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="signFinal()"><!-- --></A><H3>
signFinal</H3>
<PRE>
public byte[] <B>signFinal</B>()
                 throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method finalizes a signing operation and returns the final result. Use this method, if you
 fed in the data using signUpdate. If you used the sign(byte[]) method, you need not (and shall
 not) call this method, because sign(byte[]) finalizes the signing operation itself.<DD><DL>
<DT><B>Returns:</B><DD>The final result of the signing operation; i.e. the signature value.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If calculating the final signature value failed.</DL>
</DD>
</DL>
<HR>

<A NAME="signRecoverInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
signRecoverInit</H3>
<PRE>
public void <B>signRecoverInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                            <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
                     throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new signing operation for signing with recovery. The application must call this
 method before calling signRecover. Before initializing a new operation, any currently pending
 operation must be finalized using the appropriate *Final method (e.g. digestFinal()). There are
 exceptions for dual-function operations. This method requires the mechansim to use for signing
 and the key for this oepration. The key must have set its sign-recover flag. For the mechanism
 the application may use a constant defined in the Mechanism class. Notice that the key and the
 mechanism must be compatible; i.e. you cannot use a DES key with the RSA mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.RSA_9796.<DD><CODE>key</CODE> - The signing key to use.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="signRecover(byte[])"><!-- --></A><H3>
signRecover</H3>
<PRE>
public byte[] <B>signRecover</B>(byte[]&nbsp;data)
                   throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Signs the given data with the key and mechansim given to the signRecoverInit method. This
 method finalizes the current sign-recover operation; there is no equivalent method to
 signUpdate for signing with recovery.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The data to sign.<DT><B>Returns:</B><DD>The signed data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If signing the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="verifyInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
verifyInit</H3>
<PRE>
public void <B>verifyInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                       <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
                throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new verification operation. You can use it for verifying signatures and MACs. The
 application must call this method before calling any other verify* operation. Before
 initializing a new operation, any currently pending operation must be finalized using the
 appropriate *Final method (e.g. digestFinal()). There are exceptions for dual-function
 operations. This method requires the mechansim to use for verification and the key for this
 oepration. The key must have set its verify flag. For the mechanism the application may use a
 constant defined in the Mechanism class. Notice that the key and the mechanism must be
 compatible; i.e. you cannot use a DES key with the RSA mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.RSA_PKCS.<DD><CODE>key</CODE> - The verification key to use.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="verify(byte[], byte[])"><!-- --></A><H3>
verify</H3>
<PRE>
public void <B>verify</B>(byte[]&nbsp;data,
                   byte[]&nbsp;signature)
            throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Verifies the given signature against the given data with the key and mechansim given to the
 verifyInit method. This method finalizes the current verification operation; i.e. the
 application need (and should) not call verifyFinal() after this call. For verifying with
 multiple pices of data use verifyUpdate and verifyFinal. This method throws an exception, if
 the verification of the signature fails.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The data that was signed.<DD><CODE>signature</CODE> - The signature or MAC to verify.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If verifying the signature fails. This is also the case, if the signature is
              forged.</DL>
</DD>
</DL>
<HR>

<A NAME="verifyUpdate(byte[])"><!-- --></A><H3>
verifyUpdate</H3>
<PRE>
public void <B>verifyUpdate</B>(byte[]&nbsp;part)
                  throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method can be used to verify a signature with multiple pieces of data; e.g. buffer-size
 pieces when reading the data from a stream. To verify the signature or MAC call verifyFinal
 after feeding in all data using this method.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to verify against.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If verifying (e.g. digesting) the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="verifyFinal(byte[])"><!-- --></A><H3>
verifyFinal</H3>
<PRE>
public void <B>verifyFinal</B>(byte[]&nbsp;signature)
                 throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method finalizes a verification operation. Use this method, if you fed in the data using
 verifyUpdate. If you used the verify(byte[]) method, you need not (and shall not) call this
 method, because verify(byte[]) finalizes the verification operation itself. If this method
 verified the signature successfully, it returns normally. If the verification of the signature
 fails, e.g. if the signature was forged or the data was modified, this method throws an
 exception.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signature</CODE> - The signature value.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If verifying the signature fails. This is also the case, if the signature is
              forged.</DL>
</DD>
</DL>
<HR>

<A NAME="verifyRecoverInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
verifyRecoverInit</H3>
<PRE>
public void <B>verifyRecoverInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                              <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
                       throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new verification operation for verification with data recovery. The application
 must call this method before calling verifyRecover. Before initializing a new operation, any
 currently pending operation must be finalized using the appropriate *Final method (e.g.
 digestFinal()). This method requires the mechansim to use for verification and the key for this
 oepration. The key must have set its verify-recover flag. For the mechanism the application may
 use a constant defined in the Mechanism class. Notice that the key and the mechanism must be
 compatible; i.e. you cannot use a DES key with the RSA mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.RSA_9796.<DD><CODE>key</CODE> - The verification key to use.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="verifyRecover(byte[])"><!-- --></A><H3>
verifyRecover</H3>
<PRE>
public byte[] <B>verifyRecover</B>(byte[]&nbsp;signature)
                     throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Signs the given data with the key and mechansim given to the signRecoverInit method. This
 method finalizes the current sign-recover operation; there is no equivalent method to
 signUpdate for signing with recovery.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signature</CODE> - The data to sign.<DT><B>Returns:</B><DD>The signed data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If signing the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="digestEncryptedUpdate(byte[])"><!-- --></A><H3>
digestEncryptedUpdate</H3>
<PRE>
public byte[] <B>digestEncryptedUpdate</B>(byte[]&nbsp;part)
                             throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Dual-function. Continues a multipart dual digest and encryption operation. This method call can
 also be combined with calls to digestUpdate, digestKey and encryptUpdate. Call digestFinal and
 encryptFinal to get the final results.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to digest and encrypt.<DT><B>Returns:</B><DD>The intermediate result of the encryption.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If digesting or encrypting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="decryptDigestUpdate(byte[])"><!-- --></A><H3>
decryptDigestUpdate</H3>
<PRE>
public byte[] <B>decryptDigestUpdate</B>(byte[]&nbsp;part)
                           throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Dual-function. Continues a multipart dual decrypt and digest operation. This method call can
 also be combined with calls to digestUpdate, digestKey and decryptUpdate. It is the recovered
 plaintext that gets digested in this method call, not the given encryptedPart. Call digestFinal
 and decryptFinal to get the final results.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to decrypt and digest.<DT><B>Returns:</B><DD>The intermediate result of the decryption; the decrypted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If decrypting or digesting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="signEncryptUpdate(byte[])"><!-- --></A><H3>
signEncryptUpdate</H3>
<PRE>
public byte[] <B>signEncryptUpdate</B>(byte[]&nbsp;part)
                         throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Dual-function. Continues a multipart dual sign and encrypt operation. Calls to this method can
 also be combined with calls to signUpdate and encryptUpdate. Call signFinal and encryptFinal to
 get the final results.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to sign and encrypt.<DT><B>Returns:</B><DD>The intermediate result of the encryption; the encrypted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If signing or encrypting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="decryptVerifyUpdate(byte[])"><!-- --></A><H3>
decryptVerifyUpdate</H3>
<PRE>
public byte[] <B>decryptVerifyUpdate</B>(byte[]&nbsp;encryptedPart)
                           throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Dual-function. Continues a multipart dual decrypt and verify operation. This method call can
 also be combined with calls to decryptUpdate and verifyUpdate. It is the recovered plaintext
 that gets verified in this method call, not the given encryptedPart. Call decryptFinal and
 verifyFinal to get the final results.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>encryptedPart</CODE> - The piece of data to decrypt and verify.<DT><B>Returns:</B><DD>The intermediate result of the decryption; the decrypted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If decrypting or verifying the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="generateKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
generateKey</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A> <B>generateKey</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                          <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;template)
                   throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Generate a new secret key or a set of domain parameters. It uses the set attributes of the
 template for setting the attributes of the new key object. As mechanism the application can use
 a constant of the Mechanism class.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to generate a key for; e.g. Mechanism.DES to generate a DES key.<DD><CODE>template</CODE> - The template for the new key or domain parameters; e.g. a DESSecretKey object which
          has set certain attributes.<DT><B>Returns:</B><DD>The newly generated secret key or domain parameters.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If generating a new secert key or domain parameters failed.</DL>
</DD>
</DL>
<HR>

<A NAME="generateKeyPair(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Object, iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
generateKeyPair</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/KeyPair.html">KeyPair</A> <B>generateKeyPair</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                               <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;publicKeyTemplate,
                               <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;privateKeyTemplate)
                        throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Generate a new public key - private key key-pair and use the set attributes of the template
 objects for setting the attributes of the new public key and private key objects. As mechanism
 the application can use a constant of the Mechanism class.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to generate a key for; e.g. Mechanism.RSA to generate a new RSA
          key-pair.<DD><CODE>publicKeyTemplate</CODE> - The template for the new public key part; e.g. a RSAPublicKey object which has set
          certain attributes (e.g. public exponent and verify).<DD><CODE>privateKeyTemplate</CODE> - The template for the new private key part; e.g. a RSAPrivateKey object which has set
          certain attributes (e.g. sign and decrypt).<DT><B>Returns:</B><DD>The newly generated key-pair.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If generating a new key-pair failed.</DL>
</DD>
</DL>
<HR>

<A NAME="wrapKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
wrapKey</H3>
<PRE>
public byte[] <B>wrapKey</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                      <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;wrappingKey,
                      <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
               throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Wraps (encrypts) the given key with the wrapping key using the given mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use for wrapping the key.<DD><CODE>wrappingKey</CODE> - The key to use for wrapping (encrypting).<DD><CODE>key</CODE> - The key to wrap (encrypt).<DT><B>Returns:</B><DD>The wrapped key as byte array.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If wrapping the key failed.</DL>
</DD>
</DL>
<HR>

<A NAME="unwrapKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key, byte[], iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
unwrapKey</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A> <B>unwrapKey</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                     <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;unwrappingKey,
                     byte[]&nbsp;wrappedKey,
                     <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;keyTemplate)
              throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Unwraps (decrypts) the given encrypted key with the unwrapping key using the given mechanism.
 The application can also pass a template key to set certain attributes of the unwrapped key.
 This creates a key object after unwrapping the key and returns an object representing this key.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use for unwrapping the key.<DD><CODE>unwrappingKey</CODE> - The key to use for unwrapping (decrypting).<DD><CODE>wrappedKey</CODE> - The encrypted key to unwrap (decrypt).<DD><CODE>keyTemplate</CODE> - The template for creating the new key object.<DT><B>Returns:</B><DD>A key object representing the newly created key object.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If unwrapping the key or creating a new key object failed.</DL>
</DD>
</DL>
<HR>

<A NAME="deriveKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
deriveKey</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A> <B>deriveKey</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                     <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;baseKey,
                     <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;template)
              throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Derives a new key from a specified base key unsing the given mechanism. After deriving a new
 key from the base key, a new key object is created and a representation of it is returned. The
 application can provide a template key to set certain attributes of the new key object.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use for deriving the new key from the base key.<DD><CODE>baseKey</CODE> - The key to use as base for derivation.<DD><CODE>template</CODE> - The template for creating the new key object.<DT><B>Returns:</B><DD>A key object representing the newly derived (created) key object or null, if the used
         mechanism uses other means to return its values; e.g. the CKM_SSL3_KEY_AND_MAC_DERIVE
         mechanism.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If deriving the key or creating a new key object failed.</DL>
</DD>
</DL>
<HR>

<A NAME="seedRandom(byte[])"><!-- --></A><H3>
seedRandom</H3>
<PRE>
public void <B>seedRandom</B>(byte[]&nbsp;seed)
                throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Mixes additional seeding material into the random number generator.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>seed</CODE> - The seed bytes to mix in.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If mixing in the seed failed.</DL>
</DD>
</DL>
<HR>

<A NAME="generateRandom(int)"><!-- --></A><H3>
generateRandom</H3>
<PRE>
public byte[] <B>generateRandom</B>(int&nbsp;numberOfBytesToGenerate)
                      throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Generates a certain number of random bytes.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numberOfBytesToGenerate</CODE> - The number of random bytes to generate.<DT><B>Returns:</B><DD>An array of random bytes with length numberOfBytesToGenerate.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If generating random bytes failed.</DL>
</DD>
</DL>
<HR>

<A NAME="getFunctionStatus()"><!-- --></A><H3>
getFunctionStatus</H3>
<PRE>
public void <B>getFunctionStatus</B>()
                       throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Legacy function that will normally throw an PKCS11Exception with the error-code
 PKCS11Constants.CKR_FUNCTION_NOT_PARALLEL.<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - Throws always an PKCS11Excption.</DL>
</DD>
</DL>
<HR>

<A NAME="cancelFunction()"><!-- --></A><H3>
cancelFunction</H3>
<PRE>
public void <B>cancelFunction</B>()
                    throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Legacy function that will normally throw an PKCS11Exception with the error-code
 PKCS11Constants.CKR_FUNCTION_NOT_PARALLEL.<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - Throws always an PKCS11Excption.</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Returns the string representation of this object.<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the string representation of this object</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Session.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

        
          <b>IAIK PKCS#11 Wrapper</b><br>
          <font size="-1">version 1.5</font>
         
      </EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/Module.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/SessionInfo.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Session.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;<A HREF="#inner_class_summary">INNER</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

        
          <font size="-1">IAIK JavaSecurity Website <a href="http://jce.iaik.tugraz.at/">http://jce.iaik.tugraz.at/</a><br>
            <br> IAIK at Graz University of Technology, Austria, Europe 
            <br> Copyright 2001-2004, IAIK, Graz University of Technology, Inffeldgasse 16a, 8010 Graz, Austria. All Rights Reserved.
          </font>
          <font size="-1">version 1.5</font>
        
      
</BODY>
</HTML>
